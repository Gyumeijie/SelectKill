#!/bin/bash

# Renders a text based list of options that can be selected by the
# user using up, down and enter keys and returns the chosen option.
#
#   Arguments   : list of options, maximum of 256
#                 "opt1" "opt2" ...
#   Return value: selected index (0 for opt1, 1 for opt2 ...)

## settings 
. parser.sh 
if [ -e ~/.skill.conf ]; then 
   do_parsing 
else
   LISTNUM=5
   MSGNUM=3
fi


if [ $# -lt 1 ];
then
  echo "Usage: skill pattername"
  exit 1
fi

tmp=$(ps aux | grep $1 | tr '\t' ' ' | tr -s ' ')

## delete the last three entries generated by runing the script itself
## and the `grep $1` command above 
processes_info=$(echo "$tmp" | sed -e "/skill.sh $1/d" -e "/grep $1/d")
count=$(echo "$processes_info" | sed '/^$/d' | wc -l)

if [ $count -lt 1 ];
then
   echo "No process matches $1"
   exit 0
fi


## extract pid column in given line
function get_pid(){
   local pid=`echo "$1" |  cut -d" " -f2` 
   echo "${pid}" 
}


function generate_indexes(){
   local indexes=`eval echo {0..$1}`   
   echo "${indexes[@]}"
}


mapfile -t opts < <(echo "$processes_info")
let num=${#opts[@]}-1
indexes=( `generate_indexes $num`)

function select_option {
   
    local paranum=${#opts[@]}
    
    # little helpers for terminal print control and key input
    ESC=$( printf "\033")
    cursor_blink_on()  { printf "$ESC[?25h"; }
    cursor_blink_off() { printf "$ESC[?25l"; }
    cursor_to()        { printf "$ESC[$1;${2:-1}H"; }
    print_option()     { printf "[$ESC[1;91m $1 $ESC[0m]";} 
    print_marked()     { printf "[$ESC[9m $1 $ESC[29m]"; }
    print_selected()   { printf "[$ESC[7m $1 $ESC[27m]"; }
    get_cursor_row()   { IFS=';' read -sdR -p $'\E[6n' ROW COL; echo ${ROW#*[}; }
    key_input()        { read -s -n3 key 2>/dev/null >&2
                         if [[ $key = $ESC[A ]]; then echo up;    fi
                         if [[ $key = $ESC[B ]]; then echo down;  fi
                         if [[ $key = $ESC[D ]]; then echo left;  fi
                         if [[ $key = ""     ]]; then echo enter; fi; }

    # initially print empty new lines (scroll down if at bottom of screen) 
    for i in `seq $(($LISTNUM+$MSGNUM))`; do printf "\n"; done

    # determine current screen position for overwriting the options
    local lastrow=`get_cursor_row`
    local startrow=$(($lastrow - $LISTNUM))
    local msgrow=$(($startrow - $MSGNUM))

    local selected=0
    local rendernum=$LISTNUM
    if [ $paranum -lt $LISTNUM ]; then rendernum=$paranum; fi

  
    function clear_region(){
       # $1 represents the start row, $2 represents the end row
       local rows=$(($2 - $1))
       for ((i=0; i<$rows; i++)); do
          cursor_to $(($1 + $i ))
           # clear the line from the current cursor to the end of line
          printf "$ESC[0K";
       done
    }

    function print_message(){
       clear_region $msgrow $(($msgrow + $MSGNUM))
       cursor_to $msgrow
       if [[ $# -eq 0 ]]; then return; fi 

       printf "$ESC[1;43m $@ $ESC[0m"
    }
 
    function update_indexes_down(){
        local tmp=( "${indexes[@]}" )
        local lastindex=$(($rendernum - 1))

        if [ ${indexes[$lastindex]} -eq $(($paranum-1)) ]; then
            indexes=(`generate_indexes $rendernum`)
            return;
        fi

        for (( i=0; i<$rendernum; i++ )); do
           indexes[$i]=$((${tmp[$i]} + 1))
        done

        selected=$lastindex
    }

    function update_indexes_up(){
        local tmp=( "${indexes[@]}" )

        if [ $paranum -le $LISTNUM ]; then return ;fi

        if [ ${indexes[0]} == 0 ]; then 
           for (( i=0; i<$rendernum; i++ )); do
                indexes[$i]=$(($paranum - $rendernum + $i ))
           done
           return;
        fi

        for (( i=0; i<$rendernum; i++ )); do
           indexes[$i]=$((${tmp[$i]} - 1 ))
        done

        selected=0
    }

    function delete_item(){
       local let choice=$1+${indexes[0]}
       local deleted_opt=${opts[$choice]} 

       local pid=$(get_pid "$deleted_opt")
       # try first normal kill
       kill -9 $pid 2>stderr.$$ 1>stdout.$$
       local status=$?
       local msg=$(cat stderr.$$ stdout.$$); rm -f std*.$$
       
       if [ $status == 0 ]; then 
          print_message "process $pid is killed"
       elif [[ "$msg" =~ "No such process" ]]; then
          # in some cases, we kill a process, other related processes are
          # also killed, in later version I will add refresh function to 
          # better solve this problem
          print_message "process $pid already killed"
       else
          print_message 
          printf "$ESC[1;43m"
          # then try to kill with sudo           
          sudo kill -9 $pid &>/dev/null
          local status=$?
          printf "$ESC[0m"
          local currow=`get_cursor_row`
          if [ $status != 0 ]; then 
              print_message "sudo: 3 incorrect password attempts, operation is not permitted"
              return; 
          else
              print_message "process $pid is killed"
          fi 
       fi

       # delete array element
       processes_info=$(echo "$processes_info" | awk -v line=$((choice + 1)) '{if(NR != line) print $0}')
       mapfile -t opts < <(echo "$processes_info")

       local lastindex=$(($rendernum - 1))
       if [ ${indexes[$lastindex]} -eq $(($paranum-1)) ] && [ $paranum -gt $LISTNUM ]; then
           for (( i=0; i<$rendernum; i++ )); do
               let indexes[$i]=indexes[$i]-1;
          done
       fi

       ((paranum--))
       
       clear_region $startrow $(($startrow + $rendernum))

       if [ $paranum -lt $LISTNUM ];then 
          ((rendernum--));
         
          if [ $selected -eq $lastindex ] && [ $selected -gt 0 ];then
             let selected=selected-1
          fi
       fi

       if [ $rendernum -eq 0 ];then 
          cursor_blink_on
          echo "Selectively progress killing session is done."
          exit 0
       fi
    }

    # ensure cursor and input echoing back on upon a ctrl+c during read -s
    trap "cursor_blink_on; stty echo; printf '\n'; rm -f std*.$$; cursor_to $lastrow; printf "$ESC[0m"; exit" 2
    cursor_blink_off

    while true; do
        # print options by overwriting the last lines
        clear_region $startrow $(($startrow + $rendernum))
        for (( i=0; i<$rendernum; i++ )); do
           idx=${indexes[$i]}
           cursor_to $(($startrow + $i))
           if [ $i -eq $selected ]; then
               print_selected "${opts[$idx]}" 
           else
               print_option "${opts[$idx]}" 
           fi
        done

        # user key control
        case `key_input` in
            enter) break;;

            up)    ((selected--));
                   if [ $selected -lt 0 ]; then selected=$(($rendernum - 1)); update_indexes_up; fi;;

            down)  ((selected++));
                   if [ $selected -ge $rendernum ]; then selected=0; update_indexes_down; fi;;

            left)  delete_item $selected;;
        esac
    done
    
    cursor_to $lastrow
    echo "Session quits"
    cursor_blink_on
}


echo "Select one option using up/down keys, left key to confirm and enter to quit:"
echo
select_option
